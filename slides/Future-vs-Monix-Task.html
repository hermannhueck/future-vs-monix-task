<!DOCTYPE html>
<html>
  <head>
    <title>Future vs. Monix Task</title>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="keywords" content="Monix,Task,Future,Scala,Cats,Cats-Effect,IO Monad">
    <meta name="description" content="A presentation that compares the Scala Future with Monix Task">

    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 4em; }
      .remark-slide-content h2 { font-size: 2.5em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #014908e1;
        color: #f3f3f3;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
      .left-column h2:last-of-type, .left-column h3:last-child {
        color: #000;
      }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }

      /* Two-column layout 50/50 */
      .left-column-50 {
        width: 49%;
        float: left;
      }
      .right-column-50 {
        width: 49%;
        float: right;
      }

      .tiny-font {
        font-size: 1em
      }

      .medium-font {
        font-size: 1.25em
      }

      .large-font {
        font-size: 1.5em
      }

      .xlarge-font {
        font-size: 1.75em
      }

      table {
        font-family: arial, sans-serif;
        border-collapse: collapse;
        width: 100%;
      }

      td, th {
        border: 1px solid #dddddd;
        text-align: left;
        padding: 8px;
      }

      tr:nth-child(odd) {
        background-color: #dddddd;
      }
    </style>
  </head>
  <body>

<textarea id="source">

name: main-template
layout: true
class: left, top
<!---
class: left, top, inverse
-->

---

class: center

<br/>
<br/>
<br/>
# Future vs. Monix Task

<br/>
<br/>
## &copy; 2018 Hermann Hueck
<br/>
https://github.com/hermannhueck/future-vs-monix-task

---

# Abstract
<br/>

scala.concurrent.Future is familiar to most Scala devs.

This presentation first talks about referential transparency and the IO Monad.

Then it compares Future with monix.eval.Task (Monix 3.x)
with their Pros and Cons.

As Scala's *Future* is used in many ennvironments and libraries, we look at
how *Future* can be converted to *Task* and - vice versa - how *Task* to *Future*.

Often recurring on the valuable Monix *Task* doumentation at<br/>
https://monix.io/docs/3x/eval/task.html<br/>
the presentation also gives an introduction to Monix Task.

---

# Agenda

1. [Referential Transparency](#ReferentialTransparency)
1. [The IO Monad](#IOMonad)
1. [Is Future referentially transparent?](#FutureReferentiallyTransparent)
1. [What is Monix Task?](#WhatIsMonixTask)
1. [Task Execution](#TaskExecution)
1. [Task Cancelation](#TaskCancelation)
1. [Task Builders](#TaskBuilders)
1. [Converting Future to Task](#FutureToTask)
1. [Memoization](#Memoization)
1. [Task as Monad](#TaskAsMonad)
1. [Tail Recursive Loops](#TailRecursiveLoops)
1. [Async Boundaries](#AsyncBoundaries)
1. [Error Handling](#ErrorHandling)
1. [Schedulers](#Schedulers)
1. [Races](#Races)
1. [Parallelizm](#Parallelizm)
1. [CompletableFuture](#CompletableFuture)
1. [Resources](#Resources)

---

class: middle, center
name: ReferentialTransparency

# 1. Referential Transparency
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

class: xlarge-font

## Referential Transparency
<br/>

An expression is called referentially transparent if it can be replaced with its corresponding value
without changing the program's behavior. This requires that the expression is <u>___pure___</u>, that is to say
the expression value must be the same for the same inputs and its evaluation must have <u>___no side effects___</u>.

.footnote[
https://en.wikipedia.org/wiki/Referential_transparency
]

---

## Referential Transparency Benefits
<br/>

- (Equational) Reasoning about code
- Refactoring is easier
- Testing is easier
- Separate pure code from impure code
- Potential compiler optimizations (more in Haskell than in Scala)<br/>
  (e.g. memoization, parallelization, compute expressions at compile time)

.footnote[
"What Referential Transparency can do for you"<br/>
Talk by Luka Jacobowitz at ScalaIO 2017<br/>
https://www.youtube.com/watch?v=X-cEGEJMx_4
]

---

class: middle, center
name: IOMonad

# 2. The IO Monad
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## IO Program <u>with</u> side effects
<br/>

```scala
def program(): Unit = {
  print("Welcome to Scala!  What's your name?   ")
  val name = scala.io.StdIn.readLine
  println(s"Well hello, $name!")
}

program()
```
<br/>

- Whenever a method or a function returns *Unit* it is <u>***impure***.</u><br/>
It's intension is to produce a side effect.

- A <u>***pure***</u> function always returns a value of some type<br/>
  (and doesn't produce a side effect inside).

---

## IO Program (based on *Function0[A]*)<br/><u>without</u> side effects
<br/>

```scala
val program: () => Unit =  // () => Unit  is syntactic sugar for:  Function0[Unit]
  () => {
    print("Welcome to Scala!  What's your name?   ")
    val name = scala.io.StdIn.readLine
    println(s"Well hello, $name!")
  }

program()    // producing the side effects "at the end of the world"
```
<br/>

- A function returning *Unit*

- Free of side effects in it's definition

- Produces side effects only when run

---

## IO Program (based on *IO[A]*)<br/>without side effects

```scala
case class IO[A](run: () => A)
```

```scala
val program: IO[Unit] = IO {
  () => {
    print("Welcome to Scala!  What's your name?   ")
    val name = scala.io.StdIn.readLine
    println(s"Well hello, $name!")
  }
}

program.run()    // producing the side effects "at the end of the world"
```
<br/>

- *IO[A]* wraps a *Function0[A]* in a case class.

---

## Monadic IO Program without side effects

```scala
case class IO[A](run: () => A) {
  def map[B](f: A => B): IO[B] = IO { () => f(run()) }
  def flatMap[B](f: A => IO[B]): IO[B] = IO { () => f(run()).run() }
}
```

```scala
val program: IO[Unit] = for {
  _       <- IO { () => print(s"Welcome to Scala!  What's your name?   ") }
  name    <- IO { () => scala.io.StdIn.readLine }
  _       <- IO { () => println(s"Well hello, $name!") }
} yield ()

program.run()    // producing the side effects "at the end of the world"
```
<br>

- With *map* and *flatMap* *IO[A]* is monadic

- Ready for for-comprehensions.

---

## Monadic IO Program without side effects

```scala
case class IO[A](run: () => A) {
  def map[B](f: A => B): IO[B] = IO { () => f(run()) }
  def flatMap[B](f: A => IO[B]): IO[B] = IO { () => f(run()).run() }
}

object IO {
  def pure[A](value: A): IO[A] = IO { () => value }
  def eval[A](thunk: => A): IO[A] = IO { () => thunk }
}
```

```scala
// Program definition WITHOUT side effects. This program does nothing.
// It is just a bunch of monadically composed functions which do not execute.
//
val program: IO[Unit] = for {
  welcome <- IO.pure("Welcome to Scala!")
  _       <- IO.eval { print(s"$welcome  What's your name?   ") }
  name    <- IO.eval { scala.io.StdIn.readLine }
  _       <- IO.eval { println(s"Well hello, $name!") }
} yield ()

program.run()    // producing the side effects "at the end of the world"
```

- *pure* and *eval* simplify the for-comprehension.

---

## Defining other sync run* methods

```scala
case class IO[A](run: () => A) {

  def map[B](f: A => B): IO[B] = IO { () => f(run()) }
  def flatMap[B](f: A => IO[B]): IO[B] = IO { () => f(run()).run() }

  // ----- impure sync run* methods

  def runToTry: Try[A] = Try { run() }

  def runToEither: Either[Throwable, A] = runToTry.toEither
}
```

```scala
// running the program synchronously ...

val v1: Unit = program.run()                    // may throw an exception

val v2: Try[Unit] = program.runToTry

val v3: Either[Throwable, Unit] = program.runToEither
```

---

## Defining async run* methods

```scala
case class IO[A](run: () => A) {
  // ...
  // ----- impure async run* methods

  // returns a Future that runs the task eagerly on another thread
  def runToFuture(implicit ec: ExecutionContext): Future[A] =
    Future { run() }

  // runs the IO in a Runnable on the given ExecutionContext
  // and then executes the specified Try based callback
  def runOnComplete(callback: Try[A] => Unit)
                                  (implicit ec: ExecutionContext): Unit = {
    ec.execute(new Runnable {
      override def run(): Unit = callback(runToTry)
    })
  }

  // runs the IO in a Runnable on the given ExecutionContext
  // and then executes the specified Either based callback
  def runAsync(callback: Either[Throwable, A] => Unit)
                                  (implicit ec: ExecutionContext): Unit = {
    ec.execute(new Runnable {
      override def run(): Unit = callback(runToEither)
    })
  }
}
```

---

## Using the async run* methods
<br/>

```scala
// check username and password for correctness
def authenticate(username: String, password: String): IO[Boolean] = ???

// check Maggie's username and password for correctness
val checkMaggie: IO[Boolean] = authenticate("maggie", "maggie-pw")
```

```scala
// running 'checkMaggie' asynchronously ...

implicit val ec: ExecutionContext = ExecutionContext.global

val future: Future[Boolean] = checkMaggie.runToFuture
future onComplete tryCallback
//=> true

checkMaggie runOnComplete tryCallback
//=> true

checkMaggie runAsync eitherCallback
//=> true
```

---

class: middle, center, large-font

## Monix Task is the <u>IO Monad</u>

... a bit more sophisticated than my implementation.

;-)

But it can also be seen as ...

## a <u>lazy Future</u>.

---

class: middle, center
name: FutureReferentiallyTransparent

# 3. Is *Future* referentially transparent?
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Is *Future* referentially transparent?

```scala
val future1: Future[(Int, Int)] = {
  val atomicInt = new AtomicInteger(0)
  val future: Future[Int] = Future { atomicInt.incrementAndGet }
  for {
    x <- future
    y <- future
  } yield (x, y)
}

future1 onComplete println     // Success((1,1))
```

```scala
// same as future1, but inlined
val future2: Future[(Int, Int)] = {
  val atomicInt = new AtomicInteger(0)
  for {
    x <- Future { atomicInt.incrementAndGet }
    y <- Future { atomicInt.incrementAndGet }
  } yield (x, y)
}

future2 onComplete println     // Success((1,2))    <-- not the same result
```

--

## No!

---

## Is Monix *Task* referentially transparent?

```scala
val task1: Task[(Int, Int)] = {
  val atomicInt = new AtomicInteger(0)
  val task: Task[Int] = Task { atomicInt.incrementAndGet }
  for {
    x <- task
    y <- task
  } yield (x, y)
}

task1 runAsync println     // Success((1,2))
```

```scala
// same as task1, but inlined
val task2: Task[(Int, Int)] = {
  val atomicInt = new AtomicInteger(0)
  for {
    x <- Task { atomicInt.incrementAndGet }
    y <- Task { atomicInt.incrementAndGet }
  } yield (x, y)
}

task2 runAsync println     // Success((1,2))    <-- same result
```


--

## Yes!

---

class: middle, center
name: WhatIsMonixTask

# 4. What is Monix Task?
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Monix 3.x

- library for asynchronous, reactive computations in Scala

- dependent on: Cats, Cats Effect

### Monix provides in different sub-projects/packages:

- *monix.execution.<u>**Scheduler**</u>*: which extends *scala.concurrrent.ExecutionContext*

- *monix.eval.<u>**Task**</u>*: an abstaction for possibly asynchronously evaluated effects

- *monix.eval.<u>**Coeval**</u>*: an abstaction for synchronous effects

- *monix.reactive.{<u>**Observable**</u>, Observer, Subscriber, Consumer}*: a push-based streaming library (compatible with the *reactivestreams.org* spec)

- *monix.tail.<u>**Iterant**</u>*: a pull-based streaming library (compatible with the *reactivestreams.org* spec)

---

## Monix Task
<br/>

- inspired by: Haskell's IO Monad, Scalaz Task

- implementation of the IO Monad for Scala

- lazy and referentially transparent alternative for *scala.concurrrent.Future*

- good interop with *Future*: easy to turn *Future* to *Task* or *Task* to *Future*

---

## Comparison of Features

<table>
    <tr> <th></th><th><u>Future</u></th><th><u>Task</u></th> </tr>
    <tr> <td>Evaluation</td><td>eager / strict</td><td>lazy / non-strict</td> </tr>
    <tr> <td>Memoization</td><td>always</td><td>possible, default: no</td> </tr>
    <tr> <td>Referential Transparency &nbsp;</td><td>no</td><td>yes</td> </tr>
    <tr> <td>Supports cancelation</td><td>no</td><td>yes</td> </tr>
    <tr> <td>Supports blocking</td><td>yes</td><td>no (possible via Future)</td> </tr>
    <tr> <td>Supports sync execution</td><td>no</td><td>yes</td> </tr>
    <tr> <td>Runs on an other thread</td><td>always</td><td>not necessarily</td> </tr>
    <tr> <td>Supports green threads</td><td>no</td><td>yes</td> </tr>
    <tr> <td>Requires implicit ...</td><td>ExecutionContext<br/>(for nearly every method)</td><td>Scheduler<br/>(only when run)</td> </tr>
    <tr> <td>Stack Safety</td><td>no</td><td>yes (due to trampolining)</td> </tr>
    <tr> <td>Supports ScalaJS</td><td>yes</td><td>yes</td> </tr>
</table>

---

class: middle, center
name: TaskExecution

# 5. Task Execution
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

<br/>
## build.sbt
<br/>
<br/>

```scala
libraryDependencies += "io.monix" %% "monix" % "3.0.0-RC2"
```

---

## Running a Task requires an implicit *Scheduler*

--

Either ...

```scala
import monix.execution.Scheduler.Implicits.global
```

or create an implicit instance ...

```scala
import monix.execution.Scheduler.global
implicit val scheduler: Scheduler = Scheduler.global
```

--
- *Scheduler* is a subclass of *ExecutionContext*, hence is serves as well as an *ExecutionContext* for *Future*.

--

- The global *Scheduler* is backed by the global *ExecutionContext* which is backed by Java's *ForkJoinPool*.

--

- *Future* requires an *ExecutionContext* for almost every method (*apply*, *map*, *flatMap*, *onComplete*, etc.) whereas ...

--

- *Task* (due to it's laziness) requires a *Scheduler* only when run.

---

## Running a *Task*

--

- *Future* is eager. It starts running when you create it.

```scala
implicit val ec: ExecutionContext = ExecutionContext.global
                                                    // needs EC to create Future
val task: Future[Int] = Future { compute }          // starts running HERE!

val callback: Try[Int] => Unit = {                  // Try based callback
  case Success(result) => println(s"result = $result")
  case Failure(ex) => println(s"ERROR: ${ex.getMessage}")
}

task onComplete callback
```

--

- *Task* is a function, hence lazy. By it's creation nothing is run.

```scala
val task: Task[Int] = Task { compute }

val callback: Either[Throwable, Int] => Unit = {    // Either based callback
  case Right(result) => println(s"result = $result")
  case Left(ex) => println(s"ERROR: ${ex.getMessage}")
}

implicit val scheduler: Scheduler = Scheduler.global
                                                    // needs Scheduler to run Task
task runAsync callback                              // starts running HERE!
```

---

## Two flavours of *Callback*

--

- Both are *Either* based.

```scala
val callback: Either[Throwable, Int] => Unit = {
  case Right(result) => println(s"result = $result")
  case Left(ex) => println(s"ERROR: ${ex.getMessage}")
}
```

```scala
val callback: Callback[Throwable, Int] = new Callback[Throwable, Int] {
  def onSuccess(result: Int): Unit = println(s"result = $result")
  def onError(ex: Throwable): Unit = println(s"ERROR: ${ex.getMessage}")
}
```

--

- A *Callback* is a subclass of a function of type (Either[E, A] => Unit).

```scala
package monix.execution

abstract class Callback[-E, -A] extends (Either[E, A] => Unit) {

  def onSuccess(value: A): Unit
  def onError(e: E): Unit
  // ...
}
```

---

## Converting *Task* to *Future*

- *Task#runToFuture* turns a *Task* into a *Future* and runs it.

- A *Scheduler* is required in implicit scope.

--

```scala
val task: Task[Int] = Task {
  compute
}

implicit val scheduler: Scheduler = Scheduler.global

val future: Future[Int] = task.runToFuture

val callback: Try[Int] => Unit = {                    // Try based callback
  case Success(result) => println(s"result = $result")
  case Failure(ex) => println(s"ERROR: ${ex.getMessage}")
}

future onComplete callback
```

---

## *Task* cannot be blocked (directly)

- The API of *Task* doesn't support any means to wait for a result.

- But (if really needed) we can convert *Task* to *Future* and wait for the Future's result to become available.

--

```scala
val task: Task[Int] = Task {
  compute
}.delayExecution(1.second)

implicit val scheduler: Scheduler = Scheduler.global

val future: Future[Int] = task.runToFuture

val result = Await.result(future, 3.seconds)
println(s"result = $result")
```

---

## *Task#foreach*

- corresponds to *Future#foreach

- *Task#foreach* runs the *Task*.

- It processes the result, but ignores possible errors.

--

```scala
val task: Task[Int] = Task {
  compute                      // returns an Int or throws an exception
}

implicit val scheduler: Scheduler = Scheduler.global

task foreach { result => println(s"result = $result") }

// prints computed value in case of success
// prints nothing value in case of error
```

- Use *foreach* only if the *Task* is guaranteed not to throw an *Exception*.

---

## *Task#failed*

- corresponds to *Future#failed

- Returns a failed projection of the current *Task*.

- If the source fails we get a *Task[Throwable]* containing the error.<br/>
If the source *Task* succeeds we get a *NoSuchElementException*.

--

```scala
val task: Task[Int] = Task {
  throw new IllegalStateException("illegal state")
}

val failed: Task[Throwable] = task.failed

implicit val scheduler: Scheduler = Scheduler.global

task foreach println
// prints nothing
failed foreach println
// prints: java.lang.IllegalStateException: illegal state
```

---

class: middle, center
name: TaskCancelation

# 8. Task Cancelation
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Canceling a *Task*

- *Future* cannot be canceled, but *Task* can.

--

```scala
val task: Task[Int] = Task {
  println("side effect")
  compute
}.delayExecution(1.second)

val callback: Either[Throwable, Int] => Unit = {
  case Right(result) => println(s"result = $result")
  case Left(ex) => println(s"ERROR: ${ex.getMessage}")
}

implicit val scheduler: Scheduler = Scheduler.global

val cancelable: Cancelable = task runAsync callback

// If we change our mind...
cancelable.cancel()
```

---

## *Cancelable* & *CancelableFuture*

A *Cancelable* is a trait with a *cancel* method.

```scala
package monix.execution

trait Cancelable extends Serializable {
  def cancel(): Unit
}
```

--

- *CancelableFuture* is a *(Future with Cancelable)*, hence a *Future* augmented with a *cancel* method.

```scala
package monix.execution

sealed abstract class CancelableFuture[+A] extends Future[A] with Cancelable {
  // ...
}
```

---

## Canceling a *Future*

- *Task#runToFuture* returns a *CancelableFuture*.

--

```scala
val task: Task[Int] = Task {
  compute
}.delayExecution(1.second)

implicit val scheduler: Scheduler = Scheduler.global

val future: CancelableFuture[Int] = task.runToFuture

future onComplete {
  case Success(result) => println(s"result = $result")
  case Failure(ex) => println(s"ERROR: ${ex.getMessage}")
}

// If we change our mind...
future.cancel()
```

---

class: middle, center
name: Memoization

# 7. Memoization
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Memoization - Overview

--

```scala
// non-strict + memoized evaluation - equivalent to a lazy val
val task = Task.eval { println("side effect"); "some value" } // same as apply
val memoized = task.memoize
```

--

```scala
// non-strict + memoized evaluation - equivalent to a lazy val
Task.evalOnce { println("side effect"); "memoized" }
```

--

```scala
// memoized only if successful
val task = Task.eval { println("side effect"); "some value" }
val memoizedIfSuccessful = task.memoizeOnSuccess
```

--

.footnote[
[Skip details](#TaskBuilders)
]

---

## *Task#memoize*

- memoizes (caches) the *Task*'s result on the first run (like a *lazy val*)

- is impure, as memoization is a side effect

- guarantees idempotency

--

```scala
val task = Task {
  println("side effect")
  fibonacci(20)
}

val memoized = task.memoize

memoized runAsync printCallback
//=> side effect
//=> 10946

// Result was memoized on the first run!
memoized runAsync printCallback
//=> 10946
```

---

## *Task.evalOnce*

- evaluates a thunk lazily on the first run and memoizes/caches the result

- is impure, as memoization is a side effect

- guarantees idempotency

- *Task.evalOnce { thunk }* <-> *Task { thunk }.memoize*

--

```scala
val task = Task.evalOnce {
  println("side effect")
  fibonacci(20)
}

implicit val scheduler: Scheduler = Scheduler.global

task runAsync printCallback
//=> side effect
//=> 10946

// Result was memoized on the first run!
task runAsync printCallback
//=> 10946
```

---

## *Task#memoizeOnSuccess*

- memoizes (caches) the *Task*'s result on the first run only if it succeeds

- is impure, as memoization is a side effect

--

```scala
var effect = 0

val source = Task.eval {
  println("side effect")
  effect += 1
  if (effect < 3) throw new RuntimeException("dummy") else effect
}

val cached = source.memoizeOnSuccess

cached runAsync printCallback   //=> java.lang.RuntimeException: dummy
cached runAsync printCallback   //=> java.lang.RuntimeException: dummy
cached runAsync printCallback   //=> 3
cached runAsync printCallback   //=> 3
```

---

class: middle, center
name: TaskBuilders

# 8. Task Builders
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Task Builders - Overview

--

```scala
// non-strict evaluation - equivalent to a function
Task.eval { println("side effect"); "always" }
```

--

```scala
// strict evaluation - lifts a pure value into Task context
Task.now { println("side effect"); "immediate" }
```

--

```scala
// strict evaluation - lifts a Throwable into Task context
Task.raiseError { println("side effect"); new Exception }
```

--

```scala
// non-strict + memoized evaluation - equivalent to a lazy val
Task.evalOnce { println("side effect"); "memoized" }
```

--

```scala
// non-strict evaluation - turns a (possibly eager) Task into a lazy one
Task.defer { println("side effect"); Task.now("no longer immediate") }
```

--

```scala
// non-strict evaluation on a different "logical" thread
Task.evalAsync { println("side effect"); "always on different thread" }
```
--

.footnote[
[Skip details](#FutureToTask)
]

---

name: TaskEval

## *Task.eval* / *Task.apply* / *Task.delay*

- corresponds to *Future.apply*

- evaluates a thunk lazily

--

```scala
val task = Task.eval {
  println("side effect")
  fibonacci(20)
}

implicit val scheduler: Scheduler = Scheduler.global

task foreach println
//=> side effect
//=> 10946

// The evaluation (and thus all contained side effects)
// gets triggered on each run:
task runAsync printCallback
//=> side effect
//=> 10946
```

---

name: TaskNow

## *Task.now* / *Task.pure*

- corresponds to *Future.successful*

- lifts a pure value into the *Task* context

- evaluates eagerly / immediately, never spawning a separate thread

- !!! Don't use it for computations and side effects, only for pure values !!!

--

```scala
val task = Task.now {
  println("(eagerly produced) side effect; DON'T DO THAT !!")
  42
}
//=> (eagerly produced) side effect; DON'T DO THAT !!

implicit val scheduler: Scheduler = Scheduler.global

task runAsync printCallback
//=> 42
```

---

name: TaskUnit

## *Task.unit*

- corresponds to *Future.unit*

- lifts a pure Unit value into the *Task* context

- evaluates eagerly / immediately, never spawning a separate thread

- Task.unit <-> Task.now(())

--

```scala
val task: Task[Unit] = Task.unit

implicit val scheduler: Scheduler = Scheduler.global

task runAsync println
//=> Right(())
```

---

name: TaskRaiseError

## *Task.raiseError*

- corresponds to *Future.failed*

- lifts a *Throwable* into the *Task* context (analogous to *Task.now*)

- evaluates eagerly / immediately, never spawning a separate thread

- !!! Don't use it for computations and side effects, only for pure errors/exceptions !!!

--

```scala
val task = Task.raiseError {
  println("(eagerly produced) side effect; DON'T DO THAT !!")
  new IllegalStateException("illegal state")
}
//=> (eagerly produced) side effect; DON'T DO THAT !!

implicit val scheduler: Scheduler = Scheduler.global

task runAsync printCallback
//=> java.lang.IllegalStateException: illegal state
```

---

name: TaskEvalOnce

## *Task.evalOnce*

- corresponds to *Future.apply*

- evaluates a thunk lazily on the first run and memoizes/caches the result

- is impure, as memoization is a side effect

- guarantees idempotency

- Task.evalOnce <--> Task.eval.memoize

--

```scala
val task = Task.evalOnce {
  println("side effect")
  fibonacci(20)
}

implicit val scheduler: Scheduler = Scheduler.global

task foreach println
//=> side effect
//=> 10946

// Result was memoized on the first run!
task runAsync printCallback
//=> 10946
```

---

name: TaskNever

## *Task.never*

- corresponds to *Future.never*

- creates a *Task* that never completes

- evaluates lazily

--

```scala
val never: Task[Int] = Task.never[Int]

val timedOut: Task[Int] =
      never.timeoutTo(3.seconds, Task.raiseError(new TimeoutException))

implicit val scheduler: Scheduler = Scheduler.global

timedOut runAsync println
// After 3 seconds:
// => Left(java.util.concurrent.TimeoutException)
```

---

name: TaskDefer

## *Task.defer* / *Task.suspend*

- takes a (possibly eager) *Task* and turns it into a lazy *Task* of the same type.

- evaluates lazily

- *Task.defer(Task.now(value))* <-> Task.eval(value)

--

```scala
val task = Task.defer {
  println("side effect")
  Task.now(42)
}

implicit val scheduler: Scheduler = Scheduler.global

task runAsync printCallback
//=> side effect
//=> 10946

// The evaluation (and thus all contained side effects)
// gets triggered on each run:
task runAsync printCallback
//=> side effect
//=> 10946
```

---

name: TaskEval

## *Task.evalAsync*

- evaluates a thunk lazily like *Task.eval*

- guaranteed to spawn a separate "logical" thread

- Task.evalAsync(a) <-> Task.eval(a).executeAsync

- See also: [Async Boundaries](#AsyncBoundaries)

--

```scala
val task = Task.evalAsync {
  println("side effect")
  fibonacci(20)
}

implicit val scheduler: Scheduler = Scheduler.global

// The evaluation (and thus all contained side effects)
// gets triggered on each run.
// But it is run asynchronously on a different "logical" thread.
task runAsync printCallback
//=> side effect
//=> 10946
```

---

class: middle, center
name: FutureToTask

# 8. Converting Future to Task
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## *Future* to *Task* - Overview

--

```scala
// --- SOME LIBRARY ---
private def compute: Int = ???     // compute Int value

// compute Int value async - library code returns a Future
def computeAsync(implicit ec: ExecutionContext): Future[Int] = Future { compute }
```

--

```scala
// converts a Future to a effectively memoized Task. Strict evaluation !!!
import monix.execution.Scheduler.Implicits.global
val task = Task.fromFuture(computeAsync) // needs an EC
```

--

```scala
// converts a Future to a lazy Task. Non-strict evaluation !!!
import monix.execution.Scheduler.Implicits.global
val task = Task.defer(Task.fromFuture(computeAsync)) // needs an EC
```

--

```scala
// converts a Future to a lazy Task. Non-strict evaluation !!!
import monix.execution.Scheduler.Implicits.global
val task = Task.deferFuture(computeAsync) // needs an EC
```

--

```scala
// converts a Future to a lazy Task. Non-strict evaluation !!!
val task = Task.deferFutureAction(implicit scheduler => computeAsync)
// Scheduler is required when the task is run.
```

--

[Skip details](#TailRecursiveLoops)

---

## *Task.fromFuture*

- converts a *Future* to an effectively memoized *Task*. **Strict** evaluation !!!

- The *Future* starts running eagerly, before *Task.fromFuture* is invoked.

- An implicit *ExecutionContext* or *Scheduler* must be provided.

--

```scala
object library {
  def futureFactorial(n: Int)(implicit ec: ExecutionContext): Future[BigInt] =
    Future { println("side effect"); factorial(n) }
}

  import library._
  import Scheduler.Implicits.global

  // Future created before Task.fromFuture is invoked
  // Hence the Future is already running before we convert it to a Task
  val task = Task.fromFuture(futureFactorial(10))
  //=> side effect

  task foreach println
  //=> 3628800
```

---

## *Task.defer* & *Task.fromFuture*

- converts a *Future* into a lazy *Task*. **Non-strict**/lazy evaluation !!!

- *Task.defer* effectively creates a function which - when invoked - will create the *Future*.

- The *Future* doesn't start running (unless created outside *Task.defer*).

- An implicit *ExecutionContext* or *Scheduler* must be provided.

--

```scala
object library {
  def futureFactorial(n: Int)(implicit ec: ExecutionContext): Future[BigInt] =
    Future { println("side effect"); factorial(n) }
}

  import library._
  import Scheduler.Implicits.global

  val task = Task.defer {
    Task.fromFuture(futureFactorial(10))
  }

  task foreach println
  //=> side effect
  //=> 3628800
```

---

## *Task.deferFuture*

- converts a *Future* into a lazy *Task*. **Non-strict**/lazy evaluation !!!

- *Task.deferFuture(f)* <-> *Task.defer(Task.fromFuture(f))*

- The *Future* doesn't start running (unless created outside *Task.deferFuture*)..

- An implicit *ExecutionContext* or *Scheduler* must be provided.

--

```scala
object library {
  def futureFactorial(n: Int)(implicit ec: ExecutionContext): Future[BigInt] =
    Future { println("side effect"); factorial(n) }
}

  import library._
  import Scheduler.Implicits.global

  val task = Task.deferFuture(futureFactorial(10)

  task foreach println
  //=> side effect
  //=> 3628800
```

---

## *Task.deferFutureAction*

- converts a *Future* into a lazy *Task*. **Non-strict**/lazy evaluation !!!

- The *Future* doesn't start running (unless created outside *Task.deferFutureAction*)..

- **No** implicit *ExecutionContext* or *Scheduler* must be provided.

- An implicit *Scheduler* must be provided when the task is run.

--

```scala
object library {
  def futureFactorial(n: Int)(implicit ec: ExecutionContext): Future[BigInt] =
    Future { println("side effect"); factorial(n) }
}

  import library._
  
  val task = Task.deferFutureAction(implicit scheduler => futureFactorial(10))

  import Scheduler.Implicits.global

  task foreach println
  //=> side effect
  //=> 3628800
```

---

class: middle, center
name: TaskAsMonad

# 9. Task as Monad
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## *Task#map*
<br/>

```scala
val task: Task[List[(String, Int)]] =
  Task.eval {     // Attention! This Task doesn't close the resource "README.md"
    Source.fromURL("file:./README.md")
  } map {
    _.getLines
  } map {
    _.toList
  } map {
    wordCount(limit = 2)
  }
```

```scala
import Scheduler.Implicits.global

task runAsync new Callback[Throwable, List[(String, Int)]] {
  def onError(ex: Throwable): Unit =
    println(s"ERROR: ${ex.toString}")
  def onSuccess(wcList: List[(String, Int)]): Unit =
    wcList foreach { case (word, count) => println(s"$word: $count")}
}
```

---

## *Task#flatMap*
<br/>

```scala
def sumTask(from: Int, to: Int) = Task { sumOfRange(from, to) }
def fibonacciTask(num: Int) = Task { fibonacci(num) }
def factorialTask(num: Int) = Task { factorial(num) }

def computeTask(from: Int, to: Int): Task[BigInt] =
  sumTask(from, to)
    .flatMap(fibonacciTask)
    .map(_.intValue)
    .flatMap(factorialTask)
```

```scala
val task = computeTask(1, 4)

import Scheduler.Implicits.global

task runAsync printCallback
//=> 6227020800
```

---

## For-comprehension over a *Task* context
<br/>

```scala
def sumTask(from: Int, to: Int) = Task { sumOfRange(from, to) }
def fibonacciTask(num: Int) = Task { fibonacci(num) }
def factorialTask(num: Int) = Task { factorial(num) }

def computeTask(from: Int, to: Int): Task[BigInt] =
  for {
    x <- sumTask(from, to)
    y <- fibonacciTask(x)
    z <- factorialTask(y.intValue)
  } yield z
```

```scala
val task = computeTask(1, 4)

import Scheduler.Implicits.global

task runAsync printCallback
//=> 6227020800
```

---

## *Task* has a *Monad* instance

```scala
def sumF[F[_]: Monad](from: Int, to: Int): F[Int] =
  Monad[F].pure { sumOfRange(from, to) }

def fibonacciF[F[_]: Monad](num: Int): F[BigInt] =
  Monad[F].pure { fibonacci(num) }

def factorialF[F[_]: Monad](num: Int): F[BigInt] =
  Monad[F].pure { factorial(num) }

def computeF[F[_]: Monad](from: Int, to: Int): F[BigInt] =
  for {
    x <- sumF(from, to)
    y <- fibonacciF(x)
    z <- factorialF(y.intValue)
  } yield z
```

```scala
// reify F[] with Task
val task: Task[BigInt] = computeF[Task](1, 4)

import Scheduler.Implicits.global

task runAsync printCallback
//=> 6227020800
```

---

## *computeF* can be used with any *Monad* instance

```scala
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global
import cats.instances.future._

// reify F[] with Future
val task: Future[BigInt] = computeF[Future](1, 4)

task foreach { result => println(s"result = $result")}
//=> 6227020800
```

```scala
import cats.Id

// reify F[] with Id
val result: Id[BigInt] = computeF[Id](1, 4)     // Id[BigInt] ^= BigInt

println(s"result = $result")
//=> 6227020800
```

```scala
import cats.instances.option._

// reify F[] with Option
val maybeResult: Option[BigInt] = computeF[Option](1, 4)

maybeResult foreach { result => println(s"result = ${result}") }
//=> 6227020800
```

---

class: middle, center
name: TailRecursiveLoops

# 10. Tail Recursive Loops
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Tail recursion with annotation *@tailrec*

- With the *@tailrec* annaotation the compiler guarantees us stack-safety.

```scala
@scala.annotation.tailrec
def fibonacci(cycles: Int, x: BigInt = 0, y: BigInt = 1): BigInt =
  if (cycles > 0)
    fibonacci(cycles-1, y, x + y)
  else
    y
```

```scala
val result: BigInt = fibonacci(6)

println(result)
//=> 13
```

---

## Tail recursion with *Task*

- With *Task* the fibonacci impl is lazy (due to *Task.defer*).

- The annotation *@tailrec* is no longer required.

- The impl is nevertheless stack-safe.

```scala
def fibonacciTask(cycles: Int, x: BigInt = 0, y: BigInt = 1): Task[BigInt] =
  if (cycles > 0)
    Task.defer(fibonacciTask(cycles-1, y, x+y))
  else
    Task.now(y)
```

```scala
val task: Task[BigInt] = fibonacciTask(6)

implicit val scheduler: Scheduler = Scheduler.global

task foreach println    // fibonacci computation starts here
//=> 13
```

---

## Tail recursion with *Task#flatMap*

- With *Task* the fibonacci impl is lazy (due to *Task#flatMap*).

- The annotation *@tailrec* is no longer required.

- The impl is nevertheless stack-safe.

```scala
def fibonacciTask(cycles: Int, x: BigInt = 0, y: BigInt = 1): Task[BigInt] =
  Task.eval(cycles > 0).flatMap {
    case true =>
      fib(cycles-1, y, x+y)
    case false =>
      Task.now(y)
  }
```

```scala
val task: Task[BigInt] = fibonacciTask(6)

implicit val scheduler: Scheduler = Scheduler.global

task foreach println    // fibonacci computation starts here
//=> 13
```

---

## Mutual tail recursion

- With *Task* even mutual tail recursive calls are possible.

```scala
def odd(n: Int): Task[Boolean] =
  Task.eval(n == 0).flatMap {
    case true => Task.now(false)
    case false => if (n > 0) even(n - 1) else even(n + 1)
  }

def even(n: Int): Task[Boolean] =
  Task.eval(n == 0).flatMap {
    case true => Task.now(true)
    case false => if (n > 0) odd(n - 1) else odd(n + 1)
  }
```

```scala
val task: Task[Boolean] = even(-1000000)

implicit val scheduler: Scheduler = Scheduler.global

task foreach println
//=> true
```

---

class: middle, center
name: AsyncBoundaries

# 11. Async Boundaries
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

class: middle, center
name: ErrorHandling

# 12. Error Handling
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

class: middle, center
name: Schedulers

# 13. Schedulers
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

class: middle, center
name: Races

# 14. Races
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

class: middle, center
name: Parallelizm

# 15. Parallelizm
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

class: middle, center
name: CompletableFuture

# 16. CompletableFuture
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

class: middle, center
name: Resources

# 20. Resources
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Resources (1/2)

<br/>

- Code and Slides of this Talk:<br/>
  https://github.com/hermannhueck/future-vs-monix-task

- Monix 3.x Documentation<br/>
  https://monix.io/docs/3x/

- Monix 3.x API Documentation<br/>
  https://monix.io/api/3.0/


---

## Resources (1/2)

<br/>

- Monix Task: Lazy, Async and Awesome
  Talk by Alexandru Nedelcu at Scala Days 2017
  https://www.youtube.com/watch?v=wi97X8_JQUk

- What Referential Transparency can do for you
  Talk by Luka Jacobowitz at ScalaIO 2017
  https://www.youtube.com/watch?v=X-cEGEJMx_4

- Presentations on Monix:
  https://monix.io/presentations

---

class: middle, center

## Thanks for Listening
<br/>
<br/>
<br/>

# Q &amp; A
<br/>
<br/>
<br/>
<br/>
<br/>

https://github.com/hermannhueck/future-vs-monix-task


</textarea>

    <script src="remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        // sourceUrl: 'some-source.md',

        // Set the slideshow display ratio
        // Default: '4:3'
        // Alternatives: '16:9', ...
        ratio: '4:3',

        // Navigation options
        navigation: {
          // Enable or disable navigating using scroll
          // Default: true
          // Alternatives: false
          scroll: false,

          // Enable or disable navigation using touch
          // Default: true
          // Alternatives: false
          touch: true,

          // Enable or disable navigation using click
          // Default: false
          // Alternatives: true
          click: false
        }
      });
    </script>
  </body>
</html>
