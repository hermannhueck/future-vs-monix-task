<!DOCTYPE html>
<html>
  <head>
    <title>Future vs. Monix Task</title>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="keywords" content="Monix,Task,Future,Scala,Cats,Cats-Effect,IO Monad">
    <meta name="description" content="A presentation that compares the Scala Future with Monix Task">

    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 4em; }
      .remark-slide-content h2 { font-size: 2.5em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #014908e1;
        color: #f3f3f3;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
      .left-column h2:last-of-type, .left-column h3:last-child {
        color: #000;
      }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }

      /* Two-column layout 50/50 */
      .left-column-50 {
        width: 49%;
        float: left;
      }
      .right-column-50 {
        width: 49%;
        float: right;
      }

      .tiny-font {
        font-size: 1em
      }

      .medium-font {
        font-size: 1.25em
      }

      .large-font {
        font-size: 1.5em
      }

      .xlarge-font {
        font-size: 1.75em
      }
    </style>
  </head>
  <body>

<textarea id="source">

name: main-template
layout: true
class: left, top
<!---
class: left, top, inverse
-->

---

class: center

<br/>
<br/>
<br/>
# Future vs. Monix Task

<br/>
<br/>
## &copy; 2018 Hermann Hueck
<br/>
https://github.com/hermannhueck/future-vs-monix-task

---

# Abstract
<br/>

scala.concurrent.Future is familiar to most Scala devs.

This presentation compares Future with monix.eval.Task (Monix 3.x)
with their Pros and Cons.

It gives an introduction to Monix Task and deals with the interop between the two.

---

# Agenda
<br/>

1. [Referential Transparency](#ReferentialTransparency)
1. [The IO Monad](#IOMonad)
1. [Is Future referentially transparent?](#FutureReferentiallyTransparent)
1. [Comparison of Features](#Comparison)
1. [Execution of monix.eval.Task](#TaskExecution)
1. [Task Builders](#TaskBuilders)
1. [Converting Future to Task](#FutureToTask)
1. [Memoization](#Memoization)
1. [FlatMap](#FlatMap)
1. [Async Boundaries](#AsyncBoundaries)
1. [Resources](#Resources)

---

class: middle, center
name: ReferentialTransparency

# 1. Referential Transparency
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

class: large-font

<br/>
<br/>
## Referential Transparency
<br/>
<br/>

An expression is called referentially transparent if it can be replaced with its corresponding value
without changing the program's behavior. This requires that the expression is <u>___pure___</u>, that is to say
the expression value must be the same for the same inputs and its evaluation must have <u>___no side effects___</u>.

.footnote[
https://en.wikipedia.org/wiki/Referential_transparency
]

---

class: large-font

<br/>
<br/>
## Benefits of Referential Transparency
<br/>
<br/>

- Equational reasoning about the code
- Refactoring is easier
- Testing is easier

---

class: middle, center
name: IOMonad

# 2. The IO Monad
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## IO Program with side effects
<br/>

```scala
// program definition WITH side effects.
//
def program(): Unit = {
  print("Welcome to Scala!  What's your name?   ")
  val name = scala.io.StdIn.readLine
  println(s"Well hello, $name!")
}

program()
```
<br/>

Whenever a method or a function returns Unit <br/>
it's intension is to produce a side effect.

A <u>___pure___</u> function always returns a value of some type.

---

## IO Program (based on Function0[A])<br/>without side effects
<br/>

```scala
// Program definition WITHOUT side effects. This program does nothing.
// It is just a Function0[Unit].
//
val program: () => Unit =  // () => Unit  is syntactic sugar for:  Function0[Unit]
  () => {
    print("Welcome to Scala!  What's your name?   ")
    val name = scala.io.StdIn.readLine
    println(s"Well hello, $name!")
  }

// Running the program produces the side effects.
program()
```
<br/>

This is a function returning Unit.<br/>
It produces a side effect only when run.

---

## IO Program (based on IO[A])<br/>without side effects

```scala
// IO[A] wraps a Function0[A]
case class IO[A](run: () => A)
```

```scala
// Program definition WITHOUT side effects. This program does nothing.
// It is just a Function0[Unit] wrapped in IO.
//
val program: IO[Unit] = IO {
  () => {
    print("Welcome to Scala!  What's your name?   ")
    val name = scala.io.StdIn.readLine
    println(s"Well hello, $name!")
  }
}

// Running the program's encapsulated Function0 produces the side effects.
program.run()
```
<br/>

IO[A] just wraps a Function0[A] in a case class.

---

## Monadic IO Program without side effects

```scala
// IO[A] is a Monad wrapping a Function0[A].
// With map and flatMap it is usable in a for-comprehension.
//
case class IO[A](run: () => A) {
  def map[B](f: A => B): IO[B] = IO { () => f(run()) }
  def flatMap[B](f: A => IO[B]): IO[B] = f(run())
}
```

```scala
// Program definition WITHOUT side effects. This program does nothing.
// It is just a bunch of monadically composed functions which do not execute.
//
val program: IO[Unit] = for {
  _       <- IO { () => print(s"Welcome to Scala!  What's your name?   ") }
  name    <- IO { () => scala.io.StdIn.readLine }
  _       <- IO { () => println(s"Well hello, $name!") }
} yield ()

// Running the program's encapsulated Function0 produces the side effects.
program.run()
```
<br/>

With _map_ and _flatMap_ _IO_ is monadic and ready for for-comprehensions.

---

## Monadic IO Program without side effects

```scala
// IO[A] is a Monad wrapping a Function0[A].
// With map and flatMap it is usable in a for-comprehension.
//
case class IO[A](run: () => A) {
  def map[B](f: A => B): IO[B] = IO { () => f(run()) }
  def flatMap[B](f: A => IO[B]): IO[B] = f(run())
}

object IO {
  def pure[A](value: A): IO[A] = IO { () => value }
  def eval[A](thunk: => A): IO[A] = IO { () => thunk }
}
```

```scala
// Program definition WITHOUT side effects. This program does nothing.
// It is just a bunch of monadically composed functions which do not execute.
//
val program: IO[Unit] = for {
  welcome <- IO.pure("Welcome to Scala!")
  _       <- IO.eval { print(s"$welcome  What's your name?   ") }
  name    <- IO.eval { scala.io.StdIn.readLine }
  _       <- IO.eval { println(s"Well hello, $name!") }
} yield ()

// Running and producing the side effects "at the end of the world".
program.run()
```

---

## Defining other run* methods in case class IO

```scala
case class IO[A](run: () => A) {

  def map[B](f: A => B): IO[B] = IO { () => f(run()) }
  def flatMap[B](f: A => IO[B]): IO[B] = f(run())

  // ----- different impure run* methods to be run at the end of the world

  // runs on the current Thread returning Try[A]
  def runToTry: Try[A] = Try { run() }

  // runs on the current Thread returning Either[Throwable, A]
  def runToEither: Either[Throwable, A] = runToTry.toEither

  // returns a Future that runs the task eagerly on another thread
  def runToFuture(implicit ec: ExecutionContext): Future[A] = Future { run() }
}
```

```scala
program.run()                                  // run sync

program.runToTry                               // run sync

program.runToEither                            // run sync

implicit val ec: ExecutionContext = ExecutionContext.global

program.runToFuture                            // run async
```

---

class: middle, center
name: FutureReferentiallyTransparent

# 3. Is Future referentially transparent?
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Future is not referentially transparent!
<br/>

```scala
val future1: Future[(Int, Int)] = {
  val atomicInt = new AtomicInteger(0)
  val future: Future[Int] = Future { atomicInt.incrementAndGet }
  for {
    x <- future
    y <- future
  } yield (x, y)
}

// same as future1, but inlined
val future2: Future[(Int, Int)] = {
  val atomicInt = new AtomicInteger(0)
  for {
    x <- Future { atomicInt.incrementAndGet }
    y <- Future { atomicInt.incrementAndGet }
  } yield (x, y)
}

future1 onComplete println     // Success((1,1))
future2 onComplete println     // Success((1,2))    <-- not the same result
```

---

## Monix Task is referentially transparent!
<br/>

```scala
val task1: Task[(Int, Int)] = {
  val atomicInt = new AtomicInteger(0)
  val task: Task[Int] = Task { atomicInt.incrementAndGet }
  for {
    x <- task
    y <- task
  } yield (x, y)
}

// same as future1, but inlined
val task2: Task[(Int, Int)] = {
  val atomicInt = new AtomicInteger(0)
  for {
    x <- Task { atomicInt.incrementAndGet }
    y <- Task { atomicInt.incrementAndGet }
  } yield (x, y)
}

task1 runAsync println     // Success((1,2))
task2 runAsync println     // Success((1,2))    <-- same result
```

---

class: middle, center
name: Comparison

# 4. Comparison of Features
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Comparison of Features
<br/>

<table>
  <thead>
    <tr> <th></th><th><u>Future</u></th><th><u>Task</u></th> </tr>
  </thead>
  <tbody>
    <tr> <td>Evaluation</td><td>eager / strict</td><td>lazy / non-strict</td> </tr>
    <tr> <td>Memoization</td><td>always</td><td>possible, default: no</td> </tr>
    <tr> <td>Referential Transparency &nbsp;</td><td>no</td><td>yes</td> </tr>
    <tr> <td>Supports cancelation</td><td>no</td><td>yes</td> </tr>
    <tr> <td>Supports blocking</td><td>yes</td><td>no (possible via Future)</td> </tr>
    <tr> <td>Supports sync execution</td><td>no</td><td>yes</td> </tr>
    <tr> <td>Runs on an other thread</td><td>always</td><td>not necessarily</td> </tr>
    <tr> <td>Supports green threads</td><td>no</td><td>yes</td> </tr>
    <tr> <td>Requires implicit ...</td><td>ExecutionContext ...</td><td>Scheduler ...</td> </tr>
    <tr> <td></td><td>for nearly every method</td><td>only when run</td> </tr>
    <tr> <td>Stack Safety</td><td>no</td><td>yes (due to trampolining)</td> </tr>
    <tr> <td>Supports ScalaJS</td><td>yes</td><td>yes</td> </tr>
  </tbody>
</table>

---

class: middle, center
name: TaskExecution

# 5. Execution of monix.eval.Task
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

<br/>
## build.sbt
<br/>
<br/>

```scala
libraryDependencies += "io.monix" %% "monix" % "3.0.0-RC2"
```

---

## Running a Task requires an implicit *Scheduler*

--

Either ...

```scala
import monix.execution.Scheduler.Implicits.global
```

or create an implicit instance ...

```scala
implicit val scheduler: Scheduler = monix.execution.Scheduler.global
```

--
- *Scheduler* is a subclass of *ExecutionContext*, hence is serves as well as an *ExecutionContext* for *Future*.

--

- The global *Scheduler* is backed by the global *ExecutionContext* which is backed by Java's *ForkJoinPool*.

--

- *Future* requires an *ExecutionContext* for almost every method (*apply*, *map*, *flatMap*, *onComplete*, etc.) whereas ...

--

- *Task* (due to it's laziness) requires a *Scheduler* only when run.

---

## Running a *Task*

--

*Future* is eager. It starts running when you create it.

```scala
implicit val ec: ExecutionContext = ExecutionContext.global

val task: Future[Int] = Future { compute }

val callback: Try[Int] => Unit = {                    // Try based callback
  case Success(result) => println(s"result = $result")
  case Failure(ex) => println(s"ERROR: ${ex.getMessage}")
}

task onComplete callback
```

--

*Task* is lazy. By it's creation nothing is run.

```scala
val task: Task[Int] = Task { compute }

val callback: Either[Throwable, Int] => Unit = {      // Either based callback
  case Right(result) => println(s"result = $result")
  case Left(ex) => println(s"ERROR: ${ex.getMessage}")
}

implicit val scheduler: Scheduler = Scheduler.global

task runAsync callback
```

---

## Canceling a *Task*

--

*Future* cannot be canceled, but *Task* can.

--

```scala
val task: Task[Int] = Task {
  println("side effect")
  compute
}.delayExecution(1.second)

val callback: Either[Throwable, Int] => Unit = {
  case Right(result) => println(s"result = $result")
  case Left(ex) => println(s"ERROR: ${ex.getMessage}")
}

implicit val scheduler: Scheduler = Scheduler.global

val cancelable: Cancelable = task runAsync callback

// If we change our mind...
cancelable.cancel()
```

--

A *Cancelable* just has a method *cancel*.
```scala
package monix.execution

trait Cancelable extends Serializable {
  def cancel(): Unit
}
```

---

## Two flavours of *Callback*

Both are *Either* based.

--

```scala
val callback: Either[Throwable, Int] => Unit = {
  case Right(result) => println(s"result = $result")
  case Left(ex) => println(s"ERROR: ${ex.getMessage}")
}
```

--

```scala
val callback: Callback[Throwable, Int] = new Callback[Throwable, Int] {
  def onSuccess(result: Int): Unit = println(s"result = $result")
  def onError(ex: Throwable): Unit = println(s"ERROR: ${ex.getMessage}")
}
```

--

A *Callback* is a subclass of a function of type (Either[E, A] => Unit).

--

```scala
package monix.execution

abstract class Callback[-E, -A] extends (Either[E, A] => Unit) {

  def onSuccess(value: A): Unit
  def onError(e: E): Unit
  // ...
}
```

---

## Converting *Task* to *Future*

--

*Task#runToFuture* turns a *Task* into a *Future* and runs it.

--

A *Scheduler* is required in implicit scope.

--

```scala
val task: Task[Int] = Task {
  compute
}

implicit val scheduler: Scheduler = Scheduler.global

val future: Future[Int] = task.runToFuture

val callback: Try[Int] => Unit = {
  case Success(result) => println(s"result = $result")
  case Failure(ex) => println(s"ERROR: ${ex.getMessage}")
}

future onComplete callback
```

---

## *CancelableFuture*

--

*CancelableFuture* is a *Future* with a *cancel* method.

--

```scala
package monix.execution

sealed abstract class CancelableFuture[+A] extends Future[A] with Cancelable {
  // ...
}
```

--

*Task#runtToFuture* returns a *CancelableFuture*.

--

```scala
val task: Task[Int] = Task { compute }.delayExecution(1.second)

implicit val scheduler: Scheduler = Scheduler.global

val future: CancelableFuture[Int] = task.runToFuture

val callback: Try[Int] => Unit = {
  case Success(result) => println(s"result = $result")
  case Failure(ex) => println(s"ERROR: ${ex.getMessage}")
}

future onComplete callback

// If we change our mind...
future.cancel()
```

---

## *Task* cannot be blocked (directly)
<br/>

--

The API of *Task* doesn't support any means to wait for a result.

--

But we can convert *Task* to *Future* and wait for the Future's result to become available.

--

<br/>
```scala
val task: Task[Int] = Task {
  compute
}.delayExecution(1.second)

implicit val scheduler: Scheduler = Scheduler.global

val future: CancelableFuture[Int] = task.runToFuture

val result = Await.result(future, 3.seconds)
println(s"result = $result")
```

---

## *Task#foreach*

--

*Task#foreach* runs the *Task*.

--

It processes the result, but swallows possible errors.

--

<br/>
```scala
val task: Task[Int] = Task {
  compute // successfully returns an Int value
}

implicit val scheduler: Scheduler = Scheduler.global

task foreach { result => println(s"result = $result") }
// computed value is printed
```

--

```scala
val task: Task[Int] = Task {
  compute // throws an Exception
}

implicit val scheduler: Scheduler = Scheduler.global

task foreach { result => println(s"result = $result") }
// no error is spit out
```

---

class: middle, center
name: TaskBuilders

# 6. Task Builders
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## *Task.now* / *Task.pure*

---

## *Task.raiseError*

---

## *Task.apply* / *Task.eval* / *Task.delay*

---

## *Task.evalOnce*

---

## *Task.defer* / *Task.suspend*

---

## *Task.never*

---

## *Task.unit*

---

class: middle, center
name: FutureToTask

# 7. Converting Future to Task
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## *Task.fromFuture*

---

## *Task.deferFuture*

---

## *Task.deferFutureAction*

---

class: middle, center
name: Memoization

# 8. Memoization
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

class: middle, center
name: FlatMap

# 9. FlatMap
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

class: middle, center
name: AsyncBoundaries

# 10. Async Boundaries
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

class: middle, center
name: Resources

# 12. Resources
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Resources

<br/>

- Code and Slides of this Talk:<br/>
  https://github.com/hermannhueck/future-vs-monix-task

- Monix 3.x Documentation<br/>
  https://monix.io/docs/3x/

- Monix 3.x API Documentation<br/>
  https://monix.io/api/3.0/

---

class: middle, center

## Thanks for Listening
<br/>
<br/>
<br/>

# Q &amp; A
<br/>
<br/>
<br/>
<br/>
<br/>

https://github.com/hermannhueck/future-vs-monix-task


</textarea>

    <script src="remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        // sourceUrl: 'some-source.md',

        // Set the slideshow display ratio
        // Default: '4:3'
        // Alternatives: '16:9', ...
        ratio: '4:3',

        // Navigation options
        navigation: {
          // Enable or disable navigating using scroll
          // Default: true
          // Alternatives: false
          scroll: false,

          // Enable or disable navigation using touch
          // Default: true
          // Alternatives: false
          touch: true,

          // Enable or disable navigation using click
          // Default: false
          // Alternatives: true
          click: false
        }
      });
    </script>
  </body>
</html>
