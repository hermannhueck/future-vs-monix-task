<!DOCTYPE html>
<html>
  <head>
    <title>Future vs. Monix Task</title>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="keywords" content="Monix,Task,Future,Scala,Cats,Cats-Effect,IO Monad">
    <meta name="description" content="A presentation that compares the Scala Future with Monix Task">

    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 4em; }
      .remark-slide-content h2 { font-size: 2.5em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #014908e1;
        color: #f3f3f3;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
      .left-column h2:last-of-type, .left-column h3:last-child {
        color: #000;
      }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }

      /* Two-column layout 50/50 */
      .left-column-50 {
        width: 49%;
        float: left;
      }
      .right-column-50 {
        width: 49%;
        float: right;
      }

      .tiny-font {
        font-size: 1em
      }

      .medium-font {
        font-size: 1.25em
      }

      .large-font {
        font-size: 1.5em
      }

      .xlarge-font {
        font-size: 1.75em
      }

      table {
        font-family: arial, sans-serif;
        border-collapse: collapse;
        width: 100%;
      }

      td, th {
        border: 1px solid #dddddd;
        text-align: left;
        padding: 8px;
      }

      tr:nth-child(odd) {
        background-color: #dddddd;
      }
    </style>
  </head>
  <body>

<textarea id="source">

name: main-template
layout: true
class: left, top
<!---
class: left, top, inverse
-->

---

class: center

<br/>
<br/>
<br/>
# Future vs. Monix Task

<br/>
<br/>
## &copy; 2018 Hermann Hueck
<br/>
https://github.com/hermannhueck/future-vs-monix-task

---

# Abstract
<br/>

scala.concurrent.Future is familiar to most Scala devs.

This presentation compares Future with monix.eval.Task (Monix 3.x)
with their Pros and Cons.

It gives an introduction to Monix Task and deals with the interop between the two.

---

# Agenda
<br/>

1. [What is Monix?](#WhatIsMonix)
1. [Referential Transparency](#ReferentialTransparency)
1. [The IO Monad](#IOMonad)
1. [Is Future referentially transparent?](#FutureReferentiallyTransparent)
1. [Comparison of Features](#ComparisonOfFeatures)
1. [Task Execution](#TaskExecution)
1. [Task Cancelation](#TaskCancelation)
1. [Task Builders](#TaskBuilders)
1. [Converting Future to Task](#FutureToTask)
1. [Memoization](#Memoization)
1. [Tail Recursive Loops](#TailRecursiveLoops)
1. [Async Boundaries](#AsyncBoundaries)
1. [Resources](#Resources)

---

class: middle, center
name: WhatIsMonix

# 1. What is Monix?
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Monix 3.x

- library for asynchronous computations in Scala

- dependent on: Cats, Cats Effect

### Monix provides in different sub-projects/packages:

- *monix.execution.Scheduler*: which extends *scala.concurrrent.ExecutionContext*

- *monix.eval.Task*: an abstaction for possibly asynchronously evaluated effects

- *monix.eval.Coeval*: an abstaction for synchronous effects

- *monix.reactive.{Observable, Observer, Subscriber, Consumer}*: a push-based streaming library (compatible with the *reactivestreams.org* spec)

- *monix.tail.Iterant*: a pull-based streaming library (compatible with the *reactivestreams.org* spec)

---

## Monix Task
<br/>

- inspired by: Haskell's IO Monad, Scalaz Task

- implementation of the IO Monad for Scala

- lazy and referentially transparent alternative for *scala.concurrrent.Future*

- very good interop with *scala.concurrrent.Future*

---

class: middle, center
name: ReferentialTransparency

# 2. Referential Transparency
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

class: xlarge-font

## Referential Transparency
<br/>

An expression is called referentially transparent if it can be replaced with its corresponding value
without changing the program's behavior. This requires that the expression is <u>___pure___</u>, that is to say
the expression value must be the same for the same inputs and its evaluation must have <u>___no side effects___</u>.

.footnote[
https://en.wikipedia.org/wiki/Referential_transparency
]

---

class: xlarge-font

## RT Benefits
<br/>

- Equational reasoning about the code
- Refactoring is easier
- Testing is easier

.footnote[
https://www.youtube.com/watch?v=X-cEGEJMx_4
]

---

class: middle, center
name: IOMonad

# 3. The IO Monad
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## IO Program with side effects
<br/>

```scala
def program(): Unit = {
  print("Welcome to Scala!  What's your name?   ")
  val name = scala.io.StdIn.readLine
  println(s"Well hello, $name!")
}

program()
```
<br/>

- Whenever a method or a function returns *Unit*<br/>
it's intension is to produce a side effect.

- A <u>___pure___</u> function always returns a value of some type.

---

## IO Program (based on *Function0[A]*)<br/>without side effects
<br/>

```scala
val program: () => Unit =  // () => Unit  is syntactic sugar for:  Function0[Unit]
  () => {
    print("Welcome to Scala!  What's your name?   ")
    val name = scala.io.StdIn.readLine
    println(s"Well hello, $name!")
  }

program()    // producing the side effects "at the end of the world"
```
<br/>

- A function returning *Unit*

- Produces side effect only when run.

---

## IO Program (based on *IO[A]*)<br/>without side effects

```scala
case class IO[A](run: () => A)
```

```scala
val program: IO[Unit] = IO {
  () => {
    print("Welcome to Scala!  What's your name?   ")
    val name = scala.io.StdIn.readLine
    println(s"Well hello, $name!")
  }
}

program.run()    // producing the side effects "at the end of the world"
```
<br/>

- *IO[A]* wraps a *Function0[A]* in a case class.

---

## Monadic IO Program without side effects

```scala
case class IO[A](run: () => A) {
  def map[B](f: A => B): IO[B] = IO { () => f(run()) }
  def flatMap[B](f: A => IO[B]): IO[B] = f(run())
}
```

```scala
val program: IO[Unit] = for {
  _       <- IO { () => print(s"Welcome to Scala!  What's your name?   ") }
  name    <- IO { () => scala.io.StdIn.readLine }
  _       <- IO { () => println(s"Well hello, $name!") }
} yield ()

program.run()    // producing the side effects "at the end of the world"
```
<br>

- With _map_ and _flatMap_ _IO[A]_ is monadic and ready for for-comprehensions.

---

## Monadic IO Program without side effects

```scala
case class IO[A](run: () => A) {
  def map[B](f: A => B): IO[B] = IO { () => f(run()) }
  def flatMap[B](f: A => IO[B]): IO[B] = f(run())
}

object IO {
  def pure[A](value: A): IO[A] = IO { () => value }
  def eval[A](thunk: => A): IO[A] = IO { () => thunk }
}
```

```scala
// Program definition WITHOUT side effects. This program does nothing.
// It is just a bunch of monadically composed functions which do not execute.
//
val program: IO[Unit] = for {
  welcome <- IO.pure("Welcome to Scala!")
  _       <- IO.eval { print(s"$welcome  What's your name?   ") }
  name    <- IO.eval { scala.io.StdIn.readLine }
  _       <- IO.eval { println(s"Well hello, $name!") }
} yield ()

program.run()    // producing the side effects "at the end of the world"
```
<br>

- *pure* and *eval* simplify the for-comprehension.

---

## Defining other run* methods in case class IO

```scala
case class IO[A](run: () => A) {

  def map[B](f: A => B): IO[B] = IO { () => f(run()) }
  def flatMap[B](f: A => IO[B]): IO[B] = f(run())

  // ----- different impure run* methods to be run at the end of the world

  def runToTry: Try[A] = Try { run() }

  def runToEither: Either[Throwable, A] = runToTry.toEither

  def runToFuture(implicit ec: ExecutionContext): Future[A] = Future { run() }
}
```

```scala
program.run()                                  // run sync

program.runToTry                               // run sync

program.runToEither                            // run sync

implicit val ec: ExecutionContext = ExecutionContext.global

program.runToFuture                            // run async
```

---

class: middle, center, large-font

## Monix Task is the IO Monad

... a bit more sophisticated than my implementation.

;-)

But it can also be seen as ...

## a delayed Future.

---

class: middle, center
name: FutureReferentiallyTransparent

# 4. Is Future referentially transparent?
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Future is not referentially transparent!
<br/>

```scala
val future1: Future[(Int, Int)] = {
  val atomicInt = new AtomicInteger(0)
  val future: Future[Int] = Future { atomicInt.incrementAndGet }
  for {
    x <- future
    y <- future
  } yield (x, y)
}

future1 onComplete println     // Success((1,1))
```

```scala
// same as future1, but inlined
val future2: Future[(Int, Int)] = {
  val atomicInt = new AtomicInteger(0)
  for {
    x <- Future { atomicInt.incrementAndGet }
    y <- Future { atomicInt.incrementAndGet }
  } yield (x, y)
}

future2 onComplete println     // Success((1,2))    <-- not the same result
```

---

## Monix Task is referentially transparent!
<br/>

```scala
val task1: Task[(Int, Int)] = {
  val atomicInt = new AtomicInteger(0)
  val task: Task[Int] = Task { atomicInt.incrementAndGet }
  for {
    x <- task
    y <- task
  } yield (x, y)
}

task1 runAsync println     // Success((1,2))
```

```scala
// same as task1, but inlined
val task2: Task[(Int, Int)] = {
  val atomicInt = new AtomicInteger(0)
  for {
    x <- Task { atomicInt.incrementAndGet }
    y <- Task { atomicInt.incrementAndGet }
  } yield (x, y)
}

task2 runAsync println     // Success((1,2))    <-- same result
```

---

class: middle, center
name: ComparisonOfFeatures

# 5. Comparison of Features
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Comparison of Features

<table>
    <tr> <th></th><th><u>Future</u></th><th><u>Task</u></th> </tr>
    <tr> <td>Evaluation</td><td>eager / strict</td><td>lazy / non-strict</td> </tr>
    <tr> <td>Memoization</td><td>always</td><td>possible, default: no</td> </tr>
    <tr> <td>Referential Transparency &nbsp;</td><td>no</td><td>yes</td> </tr>
    <tr> <td>Supports cancelation</td><td>no</td><td>yes</td> </tr>
    <tr> <td>Supports blocking</td><td>yes</td><td>no (possible via Future)</td> </tr>
    <tr> <td>Supports sync execution</td><td>no</td><td>yes</td> </tr>
    <tr> <td>Runs on an other thread</td><td>always</td><td>not necessarily</td> </tr>
    <tr> <td>Supports green threads</td><td>no</td><td>yes</td> </tr>
    <tr> <td>Requires implicit ...</td><td>ExecutionContext<br/>(for nearly every method)</td><td>Scheduler<br/>(only when run)</td> </tr>
    <tr> <td>Stack Safety</td><td>no</td><td>yes (due to trampolining)</td> </tr>
    <tr> <td>Supports ScalaJS</td><td>yes</td><td>yes</td> </tr>
</table>

---

class: middle, center
name: TaskExecution

# 6. Task Execution
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

<br/>
## build.sbt
<br/>
<br/>

```scala
libraryDependencies += "io.monix" %% "monix" % "3.0.0-RC2"
```

---

## Running a Task requires an implicit *Scheduler*

--

Either ...

```scala
import monix.execution.Scheduler.Implicits.global
```

or create an implicit instance ...

```scala
import monix.execution.Scheduler.global
implicit val scheduler: Scheduler = Scheduler.global
```

--
- *Scheduler* is a subclass of *ExecutionContext*, hence is serves as well as an *ExecutionContext* for *Future*.

--

- The global *Scheduler* is backed by the global *ExecutionContext* which is backed by Java's *ForkJoinPool*.

--

- *Future* requires an *ExecutionContext* for almost every method (*apply*, *map*, *flatMap*, *onComplete*, etc.) whereas ...

--

- *Task* (due to it's laziness) requires a *Scheduler* only when run.

---

## Running a *Task*

--

- *Future* is eager. It starts running when you create it.

```scala
implicit val ec: ExecutionContext = ExecutionContext.global
                                                    // needs EC to create Future
val task: Future[Int] = Future { compute }          // starts running HERE!

val callback: Try[Int] => Unit = {                  // Try based callback
  case Success(result) => println(s"result = $result")
  case Failure(ex) => println(s"ERROR: ${ex.getMessage}")
}

task onComplete callback
```

--

- *Task* is a function, hence lazy. By it's creation nothing is run.

```scala
val task: Task[Int] = Task { compute }

val callback: Either[Throwable, Int] => Unit = {    // Either based callback
  case Right(result) => println(s"result = $result")
  case Left(ex) => println(s"ERROR: ${ex.getMessage}")
}

implicit val scheduler: Scheduler = Scheduler.global
                                                    // needs Scheduler to run Task
task runAsync callback                              // starts running HERE!
```

---

## Two flavours of *Callback*

--

- Both are *Either* based.

```scala
val callback: Either[Throwable, Int] => Unit = {
  case Right(result) => println(s"result = $result")
  case Left(ex) => println(s"ERROR: ${ex.getMessage}")
}
```

```scala
val callback: Callback[Throwable, Int] = new Callback[Throwable, Int] {
  def onSuccess(result: Int): Unit = println(s"result = $result")
  def onError(ex: Throwable): Unit = println(s"ERROR: ${ex.getMessage}")
}
```

--

- A *Callback* is a subclass of a function of type (Either[E, A] => Unit).

```scala
package monix.execution

abstract class Callback[-E, -A] extends (Either[E, A] => Unit) {

  def onSuccess(value: A): Unit
  def onError(e: E): Unit
  // ...
}
```

---

## Converting *Task* to *Future*

- *Task#runToFuture* turns a *Task* into a *Future* and runs it.

- A *Scheduler* is required in implicit scope.

--

```scala
val task: Task[Int] = Task {
  compute
}

implicit val scheduler: Scheduler = Scheduler.global

val future: Future[Int] = task.runToFuture

val callback: Try[Int] => Unit = {                    // Try based callback
  case Success(result) => println(s"result = $result")
  case Failure(ex) => println(s"ERROR: ${ex.getMessage}")
}

future onComplete callback
```

---

## *Task* cannot be blocked (directly)

- The API of *Task* doesn't support any means to wait for a result.

- But (if really needed) we can convert *Task* to *Future* and wait for the Future's result to become available.

--

```scala
val task: Task[Int] = Task {
  compute
}.delayExecution(1.second)

implicit val scheduler: Scheduler = Scheduler.global

val future: Future[Int] = task.runToFuture

val result = Await.result(future, 3.seconds)
println(s"result = $result")
```

---

## *Task#foreach*

- corresponds to *Future#foreach

- *Task#foreach* runs the *Task*.

- It processes the result, but swallows possible errors.

--

```scala
val task: Task[Int] = Task {
  compute                      // returns an Int or throws an exception
}

implicit val scheduler: Scheduler = Scheduler.global

task foreach { result => println(s"result = $result") }

// prints computed value in case of success
// prints nothing value in case of error
```

- Use *foreach* only if the *Task* is guaranteed not to throw an *Exception*.

---

## *Task#failed*

- corresponds to *Future#failed

- Returns a failed projection of the current *Task*.

- If the source fails we get a *Task[Throwable]* containing the error.<br/>
If the source *Task* succeeds we get a *NoSuchElementException*.

--

```scala
val task: Task[Int] = Task {
  throw new IllegalStateException("illegal state")
}

val failed: Task[Throwable] = task.failed

implicit val scheduler: Scheduler = Scheduler.global

task foreach println
// prints nothing
failed foreach println
// prints: java.lang.IllegalStateException: illegal state
```

---

class: middle, center
name: TaskCancelation

# 7. Task Cancelation
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Canceling a *Task*

- *Future* cannot be canceled, but *Task* can.

--

```scala
val task: Task[Int] = Task {
  println("side effect")
  compute
}.delayExecution(1.second)

val callback: Either[Throwable, Int] => Unit = {
  case Right(result) => println(s"result = $result")
  case Left(ex) => println(s"ERROR: ${ex.getMessage}")
}

implicit val scheduler: Scheduler = Scheduler.global

val cancelable: Cancelable = task runAsync callback

// If we change our mind...
cancelable.cancel()
```

---

## *Cancelable* & *CancelableFuture*

A *Cancelable* is a trait with a *cancel* method.

```scala
package monix.execution

trait Cancelable extends Serializable {
  def cancel(): Unit
}
```

--

- *CancelableFuture* is a *(Future with Cancelable)*, hence a *Future* augmented with a *cancel* method.

```scala
package monix.execution

sealed abstract class CancelableFuture[+A] extends Future[A] with Cancelable {
  // ...
}
```

---

## Canceling a *Future*

- *Task#runToFuture* returns a *CancelableFuture*.

--

```scala
val task: Task[Int] = Task {
  compute
}.delayExecution(1.second)

implicit val scheduler: Scheduler = Scheduler.global

val future: CancelableFuture[Int] = task.runToFuture

future onComplete {
  case Success(result) => println(s"result = $result")
  case Failure(ex) => println(s"ERROR: ${ex.getMessage}")
}

// If we change our mind...
future.cancel()
```

---

class: middle, center
name: Memoization

# 8. Memoization
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Memoization - Overview

--

```scala
// non-strict + memoized evaluation - equivalent to a lazy val
val task = Task.eval { println("side effect"); "some value" }
val memoized = task.memoize
```

--

```scala
// non-strict + memoized evaluation - equivalent to a lazy val
Task.evalOnce { println("side effect"); "memoized" }
```

--

```scala
// memoized only if successful
val task = Task.eval { println("side effect"); "some value" }
val memoizedIfSuccessful = task.memoizeOnSuccess
```

--

.footnote[
[Skip details](#TaskBuilders)
]

---

## *Task#memoize*

- memoizes (caches) the *Task*'s result on the first run (like a *lazy val*)

- is impure, as memoization is a side effect

- guarantees idempotency

--

```scala
val task = Task {
  println("side effect")
  fibonacci(20)
}

val memoized = task.memoize

memoized runAsync printCallback
//=> side effect
//=> 10946

// Result was memoized on the first run!
memoized runAsync printCallback
//=> 10946
```

---

## *Task.evalOnce*

- evaluates a thunk lazily on the first run and memoizes/caches the result

- is impure, as memoization is a side effect

- guarantees idempotency

- *Task.evalOnce { thunk }* <-> *Task { thunk }.memoize*

--

```scala
val task = Task.evalOnce {
  println("side effect")
  fibonacci(20)
}

implicit val scheduler: Scheduler = Scheduler.global

task runAsync printCallback
//=> side effect
//=> 10946

// Result was memoized on the first run!
task runAsync printCallback
//=> 10946
```

---

## *Task#memoizeOnSuccess*

- memoizes (caches) the *Task*'s result on the first run only if it succeeds

- is impure, as memoization is a side effect

--

```scala
var effect = 0

val source = Task.eval {
  println("side effect")
  effect += 1
  if (effect < 3) throw new RuntimeException("dummy") else effect
}

val cached = source.memoizeOnSuccess

cached runAsync printCallback   //=> java.lang.RuntimeException: dummy
cached runAsync printCallback   //=> java.lang.RuntimeException: dummy
cached runAsync printCallback   //=> 3
cached runAsync printCallback   //=> 3
```

---

class: middle, center
name: TaskBuilders

# 9. Task Builders
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Task Builders - Overview

--

```scala
// non-strict evaluation - equivalent to a function
Task.eval { println("side effect"); "always" }
```

--

```scala
// strict evaluation - lifts a pure value into Task context
Task.now { println("side effect"); "immediate" }
```

--

```scala
// strict evaluation - lifts a Throwable into Task context
Task.raiseError { println("side effect"); new Exception }
```

--

```scala
// non-strict + memoized evaluation - equivalent to a lazy val
Task.evalOnce { println("side effect"); "memoized" }
```

--

```scala
// non-strict evaluation - turns a (possibly eager) Task into a lazy one
Task.defer { println("side effect"); Task.now("no longer immediate") }
```

--

```scala
// non-strict evaluation on a different "logical" thread
Task.evalAsync { println("side effect"); "always on different thread" }
```
--

.footnote[
[Skip details](#FutureToTask)
]

---

name: TaskEval

## *Task.eval* / *Task.apply* / *Task.delay*

- corresponds to *Future.apply*

- evaluates a thunk lazily

--

```scala
val task = Task.eval {
  println("side effect")
  fibonacci(20)
}

implicit val scheduler: Scheduler = Scheduler.global

task foreach println
//=> side effect
//=> 10946

// The evaluation (and thus all contained side effects)
// gets triggered on each run:
task runAsync printCallback
//=> side effect
//=> 10946
```

---

name: TaskNow

## *Task.now* / *Task.pure*

- corresponds to *Future.successful*

- lifts a pure value into the *Task* context

- evaluates eagerly / immediately, never spawning a separate thread

- !!! Don't use it for computations and side effects, only for pure values !!!

--

```scala
val task = Task.now {
  println("(eagerly produced) side effect; DON'T DO THAT !!")
  42
}
//=> (eagerly produced) side effect; DON'T DO THAT !!

implicit val scheduler: Scheduler = Scheduler.global

task runAsync printCallback
//=> 42
```

---

name: TaskUnit

## *Task.unit*

- corresponds to *Future.unit*

- lifts a pure Unit value into the *Task* context

- evaluates eagerly / immediately, never spawning a separate thread

- Task.unit <-> Task.now(())

--

```scala
val task: Task[Unit] = Task.unit

implicit val scheduler: Scheduler = Scheduler.global

task runAsync println
//=> Right(())
```

---

name: TaskRaiseError

## *Task.raiseError*

- corresponds to *Future.failed*

- lifts a *Throwable* into the *Task* context (analogous to *Task.now*)

- evaluates eagerly / immediately, never spawning a separate thread

- !!! Don't use it for computations and side effects, only for pure errors/exceptions !!!

--

```scala
val task = Task.raiseError {
  println("(eagerly produced) side effect; DON'T DO THAT !!")
  new IllegalStateException("illegal state")
}
//=> (eagerly produced) side effect; DON'T DO THAT !!

implicit val scheduler: Scheduler = Scheduler.global

task runAsync printCallback
//=> java.lang.IllegalStateException: illegal state
```

---

name: TaskEvalOnce

## *Task.evalOnce*

- corresponds to *Future.apply*

- evaluates a thunk lazily on the first run and memoizes/caches the result

- is impure, as memoization is a side effect

- guarantees idempotency

- Task.evalOnce <--> Task.eval.memoize

--

```scala
val task = Task.evalOnce {
  println("side effect")
  fibonacci(20)
}

implicit val scheduler: Scheduler = Scheduler.global

task foreach println
//=> side effect
//=> 10946

// Result was memoized on the first run!
task runAsync printCallback
//=> 10946
```

---

name: TaskNever

## *Task.never*

- corresponds to *Future.never*

- creates a *Task* that never completes

- evaluates lazily

--

```scala
val never: Task[Int] = Task.never[Int]

val timedOut: Task[Int] =
      never.timeoutTo(3.seconds, Task.raiseError(new TimeoutException))

implicit val scheduler: Scheduler = Scheduler.global

timedOut runAsync println
// After 3 seconds:
// => Left(java.util.concurrent.TimeoutException)
```

---

name: TaskDefer

## *Task.defer* / *Task.suspend*

- takes a (possibly eager) *Task* and turns it into a lazy *Task* of the same type.

- evaluates lazily

- *Task.defer(Task.now(value))* <-> Task.eval(value)

--

```scala
val task = Task.defer {
  println("side effect")
  Task.now(42)
}

implicit val scheduler: Scheduler = Scheduler.global

task runAsync printCallback
//=> side effect
//=> 10946

// The evaluation (and thus all contained side effects)
// gets triggered on each run:
task runAsync printCallback
//=> side effect
//=> 10946
```

---

name: TaskEval

## *Task.evalAsync*

- evaluates a thunk lazily like *Task.eval*

- guaranteed to spawn a separate "logical" thread

- Task.evalAsync(a) <-> Task.eval(a).executeAsync

- See also: [Async Boundaries](#AsyncBoundaries)

--

```scala
val task = Task.evalAsync {
  println("side effect")
  fibonacci(20)
}

implicit val scheduler: Scheduler = Scheduler.global

// The evaluation (and thus all contained side effects)
// gets triggered on each run.
// But it is run asynchronously on a different "logical" thread.
task runAsync printCallback
//=> side effect
//=> 10946
```

---

class: middle, center
name: FutureToTask

# 8. Converting Future to Task
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## *Future* to *Task* - Overview

--

```scala
// --- SOME LIBRARY ---
private def compute: Int = ???     // compute Int value

// compute Int value async - library code returns a Future
def computeAsync(implicit ec: ExecutionContext): Future[Int] = Future { compute }
```

--

```scala
// converts a *Future* to a effectively memoized *Task*. Strict evaluation !!!
import monix.execution.Scheduler.Implicits.global
val task = Task.fromFuture(computeAsync) // needs an EC
```

--

```scala
// converts a *Future* to a lazy *Task*. Non-strict evaluation !!!
import monix.execution.Scheduler.Implicits.global
val task = Task.defer(Task.fromFuture(computeAsync)) // needs an EC
```

--

```scala
// converts a *Future* to a lazy *Task*. Non-strict evaluation !!!
import monix.execution.Scheduler.Implicits.global
val task = Task.deferFuture(computeAsync) // needs an EC
```

--

```scala
// converts a *Future* to a lazy *Task*. Non-strict evaluation !!!
val task = Task.deferFutureAction(implicit scheduler => computeAsync)
// Scheduler is required when the task is run.
```

--

[Skip details](#TailRecursiveLoops)

---

## *Task.fromFuture*

- converts a *Future* to a effectively memoized *Task*. **Strict** evaluation !!!

- The *Future* starts running eagerly, before *Task.fromFuture* is invoked.

- An implicit *ExecutionContext* or *Scheduler* must be provided.

--

```scala
object library {
  def futureFactorial(n: Int)(implicit ec: ExecutionContext): Future[BigInt] =
    Future { println("side effect"); factorial(n) }
}

  import library._
  import Scheduler.Implicits.global

  // Future created before Task.fromFuture is invoked
  // Hence the Future is already running before we convert it to a Task
  val task = Task.fromFuture(futureFactorial(10))
  //=> side effect

  task foreach println
  //=> 3628800
```

---

## *Task.defer* & *Task.fromFuture*

- converts a *Future* into a lazy *Task*. **Non-strict**/lazy evaluation !!!

- *Task.defer* effectively creates a function which - when invoked - will create the *Future*.

- The *Future* doesn't start running (unless created outside *Task.defer*).

- An implicit *ExecutionContext* or *Scheduler* must be provided.

--

```scala
object library {
  def futureFactorial(n: Int)(implicit ec: ExecutionContext): Future[BigInt] =
    Future { println("side effect"); factorial(n) }
}

  import library._
  import Scheduler.Implicits.global

  val task = Task.defer {
    Task.fromFuture(futureFactorial(10))
  }

  task foreach println
  //=> side effect
  //=> 3628800
```

---

## *Task.deferFuture*

- converts a *Future* into a lazy *Task*. **Non-strict**/lazy evaluation !!!

- *Task.deferFuture(f)* <-> *Task.defer(Task.fromFuture(f))*

- The *Future* doesn't start running (unless created outside *Task.deferFuture*)..

- An implicit *ExecutionContext* or *Scheduler* must be provided.

--

```scala
object library {
  def futureFactorial(n: Int)(implicit ec: ExecutionContext): Future[BigInt] =
    Future { println("side effect"); factorial(n) }
}

  import library._
  import Scheduler.Implicits.global

  val task = Task.deferFuture(futureFactorial(10)

  task foreach println
  //=> side effect
  //=> 3628800
```

---

## *Task.deferFutureAction*

- converts a *Future* into a lazy *Task*. **Non-strict**/lazy evaluation !!!

- The *Future* doesn't start running (unless created outside *Task.deferFutureAction*)..

- **No** implicit *ExecutionContext* or *Scheduler* must be provided.

- An implicit *Scheduler* must be provided when the task is run.

--

```scala
object library {
  def futureFactorial(n: Int)(implicit ec: ExecutionContext): Future[BigInt] =
    Future { println("side effect"); factorial(n) }
}

  import library._
  
  val task = Task.deferFutureAction(implicit scheduler => futureFactorial(10))

  import Scheduler.Implicits.global

  task foreach println
  //=> side effect
  //=> 3628800
```

---

class: middle, center
name: TailRecursiveLoops

# 10. Tail Recursive Loops
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

class: middle, center
name: AsyncBoundaries

# 11. Async Boundaries
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

class: middle, center
name: Resources

# 12. Resources
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Resources

<br/>

- Code and Slides of this Talk:<br/>
  https://github.com/hermannhueck/future-vs-monix-task

- Monix 3.x Documentation<br/>
  https://monix.io/docs/3x/

- Monix 3.x API Documentation<br/>
  https://monix.io/api/3.0/

---

class: middle, center

## Thanks for Listening
<br/>
<br/>
<br/>

# Q &amp; A
<br/>
<br/>
<br/>
<br/>
<br/>

https://github.com/hermannhueck/future-vs-monix-task


</textarea>

    <script src="remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        // sourceUrl: 'some-source.md',

        // Set the slideshow display ratio
        // Default: '4:3'
        // Alternatives: '16:9', ...
        ratio: '4:3',

        // Navigation options
        navigation: {
          // Enable or disable navigating using scroll
          // Default: true
          // Alternatives: false
          scroll: false,

          // Enable or disable navigation using touch
          // Default: true
          // Alternatives: false
          touch: true,

          // Enable or disable navigation using click
          // Default: false
          // Alternatives: true
          click: false
        }
      });
    </script>
  </body>
</html>
