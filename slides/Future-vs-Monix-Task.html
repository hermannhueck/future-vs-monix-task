<!DOCTYPE html>
<html>
  <head>
    <title>Future vs. Monix Task</title>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="keywords" content="Monix,Task,Future,Scala,Cats,Cats-Effect,IO Monad">
    <meta name="description" content="A presentation that compares the Scala Future with Monix Task">

    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 4em; }
      .remark-slide-content h2 { font-size: 2.5em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #014908e1;
        color: #f3f3f3;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
      .left-column h2:last-of-type, .left-column h3:last-child {
        color: #000;
      }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }

      /* Two-column layout 50/50 */
      .left-column-50 {
        width: 49%;
        float: left;
      }
      .right-column-50 {
        width: 49%;
        float: right;
      }

      .tiny-font {
        font-size: 1em
      }

      .medium-font {
        font-size: 1.25em
      }

      .large-font {
        font-size: 1.5em
      }

      .xlarge-font {
        font-size: 1.75em
      }
    </style>
  </head>
  <body>

<textarea id="source">

name: main-template
layout: true
class: left, top
<!---
class: left, top, inverse
-->

---

class: center

<br/>
<br/>
<br/>
# Future vs. Monix Task

<br/>
<br/>
## &copy; 2018 Hermann Hueck
<br/>
https://github.com/hermannhueck/future-vs-monix-task

---

# Abstract
<br/>

scala.concurrent.Future is familiar to most Scala devs.

This presentation compares Future with monix.eval.Task (Monix 3.x)
with their Pros and Cons.

It gives an introduction to Monix Task and deals with the interop between the two.

---

# Agenda
<br/>

1. [Referential Transparency](#ReferentialTransparency)
1. [The IO Monad](#IOMonad)
1. [Is Future referentially transparent?](#FutureReferentiallyTransparent)
1. [Comparison of Features](#Comparison)
1. [Getting started with monix.eval.Task](#GettingStarted)
1. [monix.execution.Scheduler](#Scheduler)
1. [Converting Task to Future](#TaskToFuture)
1. [Converting Future to Task](#FutureToTask)
1. [Resources](#Resources)

---

class: middle, center
name: ReferentialTransparency

# 1. Referential Transparency
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

class: large-font

<br/>
<br/>
## Referential Transparency
<br/>
<br/>

An expression is called referentially transparent if it can be replaced with its corresponding value
without changing the program's behavior. This requires that the expression is <u>___pure___</u>, that is to say
the expression value must be the same for the same inputs and its evaluation must have <u>___no side effects___</u>.

.footnote[
https://en.wikipedia.org/wiki/Referential_transparency
]

---

class: large-font

<br/>
<br/>
## Benefits of Referential Transparency
<br/>
<br/>

- Equational reasoning about the code
- Refactoring is easier
- Testing is easier

---

class: middle, center
name: IOMonad

# 2. The IO Monad
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## IO Program with side effects
<br/>

```scala
// program definition WITH side effects.
//
def program(): Unit = {
  print("Welcome to Scala!  What's your name?   ")
  val name = scala.io.StdIn.readLine
  println(s"Well hello, $name!")
}

program()
```

---

## IO Program without side effects
<br/>

```scala
// Program definition WITHOUT side effects. This program does nothing.
// It is just a Function0[Unit].
//
val program: () => Unit =  // () => Unit  is syntactic sugar for:  Function0[Unit]
  () => {
    print("Welcome to Scala!  What's your name?   ")
    val name = scala.io.StdIn.readLine
    println(s"Well hello, $name!")
  }

// Running the program produces the side effects.
program()
```

---

## IO Program without side effects
<br/>

```scala
// IO[A] wraps a Function0[A]
//
case class IO[A](run: () => A)
```
<br/>

```scala
// Program definition WITHOUT side effects. This program does nothing.
// It is just a Function0[Unit] wrapped in IO.
//
val program: IO[Unit] = IO {
  () => {
    print("Welcome to Scala!  What's your name?   ")
    val name = scala.io.StdIn.readLine
    println(s"Well hello, $name!")
  }
}

// Running the program's encapsulated Function0 produces the side effects.
program.run()
```

---

## Monadic IO Program without side effects

```scala
// IO[A] wraps a Function0[A].
// With map, flatMap and pure it is a Monad usable in a for-comprehension
//
case class IO[A](run: () => A) {

  def map[B](f: A => B): IO[B] = IO { () => f(run()) }

  def flatMap[B](f: A => IO[B]): IO[B] = f(run())
}

object IO {
  def pure[A](a: A): IO[A] = IO { () => a }
}
```

```scala
// Program definition WITHOUT side effects. This program does nothing.
// It is just a bunch of monadically composed functions which do not execute.
//
val program = for {
  welcome <- IO.pure("Welcome to Scala!")
  _       <- IO { () => print(s"$welcome  What's your name?   ") }
  name    <- IO { () => scala.io.StdIn.readLine }
  _       <- IO { () => println(s"Well hello, $name!") }
} yield ()

// Running the program's encapsulated Function0 produces the side effects.
program.run()
```

---

class: middle, center
name: FutureReferentiallyTransparent

# 3. Is Future referentially transparent?
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Future is not referentially transparent!
<br/>

```scala
val future1: Future[(Int, Int)] = {
  val atomicInt = new AtomicInteger(0)
  val future: Future[Int] = Future { atomicInt.incrementAndGet }
  for {
    x <- future
    y <- future
  } yield (x, y)
}

// same as future1, but inlined
val future2: Future[(Int, Int)] = {
  val atomicInt = new AtomicInteger(0)
  for {
    x <- Future { atomicInt.incrementAndGet }
    y <- Future { atomicInt.incrementAndGet }
  } yield (x, y)
}

future1 onComplete println     // Success((1,1))
future2 onComplete println     // Success((1,2))    <-- not the same result
```

---

## Monix Task is referentially transparent!
<br/>

```scala
val task1: Task[(Int, Int)] = {
  val atomicInt = new AtomicInteger(0)
  val task: Task[Int] = Task { atomicInt.incrementAndGet }
  for {
    x <- task
    y <- task
  } yield (x, y)
}

// same as future1, but inlined
val task2: Task[(Int, Int)] = {
  val atomicInt = new AtomicInteger(0)
  for {
    x <- Task { atomicInt.incrementAndGet }
    y <- Task { atomicInt.incrementAndGet }
  } yield (x, y)
}

task1 runAsync println     // Success((1,2))
task2 runAsync println     // Success((1,2))    <-- same result
```

---

class: middle, center
name: Comparison

# 4. Comparison of Features
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

<br/>
## Comparison of Features
<br/>

<table>
  <thead>
    <tr> <th></th><th>Future</th><th>Task</th> </tr>
    <tr> <th>&nbsp;</th><th>&nbsp;</th><th></th> </tr>
  </thead>
  <tbody>
    <tr> <td>Evaluation</td><td>eager / strict</td><td>lazy / non-strict</td> </tr>
    <tr> <td>Memoization</td><td>yes</td><td>no</td> </tr>
    <tr> <td>Referential Transparency &nbsp;</td><td>no</td><td>yes</td> </tr>
    <tr> <td>Cancelation support</td><td>no</td><td>yes</td> </tr>
    <tr> <td>Supports blocking</td><td>yes</td><td>no (possible via Future)</td> </tr>
    <tr> <td>Runs on an other thread</td><td>always</td><td>not necessarily</td> </tr>
    <tr> <td>Supports green threads</td><td>no</td><td>yes</td> </tr>
    <tr> <td>Requires implicit ...</td><td>ExecutionContext ...</td><td>Scheduler ...</td> </tr>
    <tr> <td></td><td>for nearly every method &nbsp;</td><td>only when run</td> </tr>
  </tbody>
</table>

---

class: middle, center
name: GettingStarted

# 5. Getting started with monix.eval.Task
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

xxxxxxxx

---

class: middle, center
name: Scheduler

# 6. monix.execution.Scheduler
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

xxxxxxxx

---

class: middle, center
name: TaskToFuture

# 5. Converting Task to Future
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

xxxxxxxx

---

class: middle, center
name: FutureToTask

# 6. Converting Future to Task
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

xxxxxxxx

---

class: middle, center
name: Resources

# 12. Resources
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Resources

<br/>

- Code and Slides of this Talk:<br/>
  https://github.com/hermannhueck/future-vs-monix-task

- Monix 3.x Documentation<br/>
  https://monix.io/docs/3x/

- Monix 3.x API Documentation<br/>
  https://monix.io/api/3.0/

---

class: middle, center

## Thanks for Listening
<br/>
<br/>
<br/>

# Q &amp; A
<br/>
<br/>
<br/>
<br/>
<br/>

https://github.com/hermannhueck/future-vs-monix-task


</textarea>

    <script src="remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        // sourceUrl: 'some-source.md',

        // Set the slideshow display ratio
        // Default: '4:3'
        // Alternatives: '16:9', ...
        ratio: '4:3',

        // Navigation options
        navigation: {
          // Enable or disable navigating using scroll
          // Default: true
          // Alternatives: false
          scroll: false,

          // Enable or disable navigation using touch
          // Default: true
          // Alternatives: false
          touch: true,

          // Enable or disable navigation using click
          // Default: false
          // Alternatives: true
          click: false
        }
      });
    </script>
  </body>
</html>
